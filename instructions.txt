/ Project Structure:
//
// leetgrind-bot/
// â”œâ”€â”€ cmd/
// â”‚Â Â  â””â”€â”€ main.goÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Entry point
// â”œâ”€â”€ config/
// â”‚Â Â  â”œâ”€â”€ config.goÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Configuration management
// â”‚Â Â  â””â”€â”€ config.yamlÂ Â Â Â Â Â Â Â Â Â Â Â Â Â  # Configuration file
// â”œâ”€â”€ internal/
// â”‚Â Â  â”œâ”€â”€ bot/
// â”‚Â Â  â”‚Â Â  â”œâ”€â”€ commands.goÂ Â Â Â Â Â Â Â Â Â  # Discord commands
// â”‚Â Â  â”‚Â Â  â”œâ”€â”€ handlers.goÂ Â Â Â Â Â Â Â Â Â  # Interaction handlers
// â”‚Â Â  â”‚Â Â  â”œâ”€â”€ middleware.goÂ Â Â Â Â Â Â Â  # Error handling middleware
// â”‚Â Â  â”‚Â Â  â””â”€â”€ scheduler.goÂ Â Â Â Â Â Â Â Â  # Daily review reminders
// â”‚Â Â  â”œâ”€â”€ database/
// â”‚Â Â  â”‚Â Â  â”œâ”€â”€ db.goÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # DB connections
// â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations.goÂ Â Â Â Â Â Â Â  # Schema migrations
// â”‚Â Â  â”‚Â Â  â””â”€â”€ models.goÂ Â Â Â Â Â Â Â Â Â Â Â  # Data models and CRUD
// â”‚Â Â  â””â”€â”€ metrics/
// â”‚Â Â Â Â Â Â  â””â”€â”€ metrics.goÂ Â Â Â Â Â Â Â Â Â Â  # Monitoring metrics
// â”œâ”€â”€ pkg/
// â”‚Â Â  â””â”€â”€ cache/
// â”‚Â Â Â Â Â Â  â””â”€â”€ cache.goÂ Â Â Â Â Â Â Â Â Â Â Â Â  # Simple caching layer
// â”œâ”€â”€ DockerfileÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Docker configuration
// â”œâ”€â”€ go.modÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Module definition
// â””â”€â”€ README.mdÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Documentation

//-----------------------------------------------------
// cmd/main.go
//-----------------------------------------------------
package main

import (
Â Â Â  "context"
Â Â Â  "os"
Â Â Â  "os/signal"
Â Â Â  "syscall"
Â Â Â  "time"

Â Â Â  "github.com/rs/zerolog"
Â Â Â  "github.com/rs/zerolog/log"

Â Â Â  "github.com/yourusername/leetgrind-bot/config"
Â Â Â  "github.com/yourusername/leetgrind-bot/internal/bot"
Â Â Â  "github.com/yourusername/leetgrind-bot/internal/database"
Â Â Â  "github.com/yourusername/leetgrind-bot/internal/metrics"
)

func main() {
Â Â Â  // Initialize structured logging
Â Â Â  zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
Â Â Â  log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339})

Â Â Â  // Load configuration
Â Â Â  cfg, err := config.Load()
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  log.Fatal().Err(err).Msg("Failed to load configuration")
Â Â Â  }

Â Â Â  // Configure log level based on configuration
Â Â Â  logLevel, err := zerolog.ParseLevel(cfg.LogLevel)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  log.Warn().Err(err).Str("fallback", "info").Msg("Invalid log level, using INFO")
Â Â Â Â Â Â Â  logLevel = zerolog.InfoLevel
Â Â Â  }
Â Â Â  zerolog.SetGlobalLevel(logLevel)

Â Â Â  // Create context that we can cancel on shutdown
Â Â Â  ctx, cancel := context.WithCancel(context.Background())
Â Â Â  defer cancel()

Â Â Â  // Initialize metrics (if enabled)
Â Â Â  if cfg.Metrics.Enabled {
Â Â Â Â Â Â Â  metricsServer := metrics.New(cfg.Metrics)
Â Â Â Â Â Â Â  go func() {
Â Â Â Â Â Â Â Â Â Â Â  if err := metricsServer.Start(); err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  log.Error().Err(err).Msg("Metrics server failed")
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }()
Â Â Â Â Â Â Â  defer metricsServer.Stop(ctx)
Â Â Â  }

Â Â Â  // Initialize database
Â Â Â  db, err := database.New(ctx, cfg.Database)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  log.Fatal().Err(err).Msg("Failed to initialize database")
Â Â Â  }
Â Â Â  defer db.Close()

Â Â Â  // Run database migrations
Â Â Â  if err := database.Migrate(ctx, db); err != nil {
Â Â Â Â Â Â Â  log.Fatal().Err(err).Msg("Failed to run database migrations")
Â Â Â  }

Â Â Â  // Create and set up Discord bot
Â Â Â  discordBot, err := bot.New(ctx, cfg.Discord, db)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  log.Fatal().Err(err).Msg("Failed to create Discord bot")
Â Â Â  }

Â Â Â  // Start the bot
Â Â Â  if err := discordBot.Start(ctx); err != nil {
Â Â Â Â Â Â Â  log.Fatal().Err(err).Msg("Failed to start bot")
Â Â Â  }
Â Â Â  log.Info().Msg("LeetGrind Bot is running! ðŸš€")

Â Â Â  // Start scheduler for daily reviews
Â Â Â  scheduler := bot.StartScheduler(ctx, discordBot, cfg.Scheduler)
Â Â Â  defer scheduler.Stop()

Â Â Â  // Wait for termination signal
Â Â Â  stop := make(chan os.Signal, 1)
Â Â Â  signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)
Â Â Â  <-stop

Â Â Â  // Create a shutdown context with timeout
Â Â Â  shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
Â Â Â  defer shutdownCancel()

Â Â Â  // Graceful shutdown
Â Â Â  log.Info().Msg("Shutting down gracefully...")
Â Â Â  if err := discordBot.Shutdown(shutdownCtx); err != nil {
Â Â Â Â Â Â Â  log.Error().Err(err).Msg("Error during bot shutdown")
Â Â Â  }
}

//-----------------------------------------------------
// config/config.go
//-----------------------------------------------------
package config

import (
Â Â Â  "fmt"
Â Â Â  "os"
Â Â Â  "path/filepath"
Â Â Â  "time"

Â Â Â  "github.com/spf13/viper"
)

// Config holds all configuration for the application
type Config struct {
Â Â Â  DiscordÂ Â  DiscordConfigÂ Â  `mapstructure:"discord"`
Â Â Â  DatabaseÂ  DatabaseConfigÂ  `mapstructure:"database"`
Â Â Â  Scheduler SchedulerConfig `mapstructure:"scheduler"`
Â Â Â  MetricsÂ Â  MetricsConfigÂ Â  `mapstructure:"metrics"`
Â Â Â  LogLevelÂ  stringÂ Â Â Â Â Â Â Â Â  `mapstructure:"log_level"`
}

// DiscordConfig holds Discord-specific configuration
type DiscordConfig struct {
Â Â Â  TokenÂ Â Â Â Â Â Â Â Â Â Â Â  stringÂ Â Â Â Â Â Â  `mapstructure:"token"`
Â Â Â  GuildIDÂ Â Â Â Â Â Â Â Â Â  stringÂ Â Â Â Â Â Â  `mapstructure:"guild_id"`
Â Â Â  CommandsTimeoutÂ Â  time.Duration `mapstructure:"commands_timeout"`
Â Â Â  InteractionExpiry time.Duration `mapstructure:"interaction_expiry"`
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
Â Â Â  DriverÂ Â Â Â Â Â Â Â  stringÂ Â Â Â Â Â Â  `mapstructure:"driver"`
Â Â Â  DSNÂ Â Â Â Â Â Â Â Â Â Â  stringÂ Â Â Â Â Â Â  `mapstructure:"dsn"`
Â Â Â  MaxOpenConnsÂ Â  intÂ Â Â Â Â Â Â Â Â Â  `mapstructure:"max_open_conns"`
Â Â Â  MaxIdleConnsÂ Â  intÂ Â Â Â Â Â Â Â Â Â  `mapstructure:"max_idle_conns"`
Â Â Â  ConnMaxLifeÂ Â Â  time.Duration `mapstructure:"conn_max_life"`
Â Â Â  QueryTimeoutÂ Â  time.Duration `mapstructure:"query_timeout"`
Â Â Â  MigrationsPath stringÂ Â Â Â Â Â Â  `mapstructure:"migrations_path"`
}

// SchedulerConfig holds configuration for the scheduler
type SchedulerConfig struct {
Â Â Â  ReviewTimeÂ Â Â Â  stringÂ Â Â Â Â Â Â  `mapstructure:"review_time"`
Â Â Â  ReviewChannelÂ  stringÂ Â Â Â Â Â Â  `mapstructure:"review_channel"`
Â Â Â  RetryAttemptsÂ  intÂ Â Â Â Â Â Â Â Â Â  `mapstructure:"retry_attempts"`
Â Â Â  RetryDelayÂ Â Â Â  time.Duration `mapstructure:"retry_delay"`
Â Â Â  LookbackPeriod time.Duration `mapstructure:"lookback_period"`
}

// MetricsConfig holds configuration for metrics collection
type MetricsConfig struct {
Â Â Â  Enabled boolÂ Â  `mapstructure:"enabled"`
Â Â Â  Address string `mapstructure:"address"`
}

// Load reads in config file and ENV variables if set
func Load() (*Config, error) {
Â Â Â  // Set defaults first
Â Â Â  setDefaults()

Â Â Â  // Try to read from config file if it exists
Â Â Â  configPaths := []string{
Â Â Â Â Â Â Â  ".",
Â Â Â Â Â Â Â  "./config",
Â Â Â Â Â Â Â  "/etc/leetgrind-bot",
Â Â Â  }

Â Â Â  for _, path := range configPaths {
Â Â Â Â Â Â Â  viper.AddConfigPath(path)
Â Â Â  }

Â Â Â  viper.SetConfigName("config")
Â Â Â  viper.SetConfigType("yaml")

Â Â Â  // Read from environment variables too
Â Â Â  viper.AutomaticEnv()
Â Â Â  viper.SetEnvPrefix("LEETGRIND")

Â Â Â  // Try to read the config file
Â Â Â  if err := viper.ReadInConfig(); err != nil {
Â Â Â Â Â Â Â  // It's okay if config file doesn't exist, we might use env vars
Â Â Â Â Â Â Â  if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("error reading config file: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  // Unmarshal config
Â Â Â  var config Config
Â Â Â  if err := viper.Unmarshal(&config); err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("unable to decode config: %w", err)
Â Â Â  }

Â Â Â  // Override token from environment if set
Â Â Â  if token := os.Getenv("DISCORD_BOT_TOKEN"); token != "" {
Â Â Â Â Â Â Â  config.Discord.Token = token
Â Â Â  }

Â Â Â  // Validate config
Â Â Â  if config.Discord.Token == "" {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("Discord bot token is required")
Â Â Â  }

Â Â Â  return &config, nil
}

// setDefaults sets default values for configuration
func setDefaults() {
Â Â Â  // Discord defaults
Â Â Â  viper.SetDefault("discord.commands_timeout", 5*time.Second)
Â Â Â  viper.SetDefault("discord.interaction_expiry", 15*time.Minute)

Â Â Â  // Database defaults
Â Â Â  viper.SetDefault("database.driver", "sqlite3")
Â Â Â  viper.SetDefault("database.dsn", "leetgrind.db")
Â Â Â  viper.SetDefault("database.max_open_conns", 10)
Â Â Â  viper.SetDefault("database.max_idle_conns", 5)
Â Â Â  viper.SetDefault("database.conn_max_life", 1*time.Hour)
Â Â Â  viper.SetDefault("database.query_timeout", 30*time.Second)
Â Â Â  viper.SetDefault("database.migrations_path", "./internal/database/migrations")

Â Â Â  // Scheduler defaults
Â Â Â  viper.SetDefault("scheduler.review_time", "08:00")
Â Â Â  viper.SetDefault("scheduler.retry_attempts", 3)
Â Â Â  viper.SetDefault("scheduler.retry_delay", 2*time.Second)
Â Â Â  viper.SetDefault("scheduler.lookback_period", 24*time.Hour)

Â Â Â  // Metrics defaults
Â Â Â  viper.SetDefault("metrics.enabled", false)
Â Â Â  viper.SetDefault("metrics.address", ":9090")

Â Â Â  // Logging defaults
Â Â Â  viper.SetDefault("log_level", "info")
}

// Example config.yaml file
/*
discord:
Â  token: "" # Set via environment variable LEETGRIND_DISCORD_TOKEN or DISCORD_BOT_TOKEN
Â  guild_id: "" # For testing with a specific guild, empty for global commands
Â  commands_timeout: 5s
Â  interaction_expiry: 15m

database:
Â  driver: sqlite3
Â  dsn: leetgrind.db
Â  max_open_conns: 10
Â  max_idle_conns: 5
Â  conn_max_life: 1h
Â  query_timeout: 30s
Â  migrations_path: ./internal/database/migrations

scheduler:
Â  review_time: "08:00"
Â  review_channel: "channel_id_here"
Â  retry_attempts: 3
Â  retry_delay: 2s
Â  lookback_period: 24h

metrics:
Â  enabled: false
Â  address: ":9090"

log_level: info
*/

//-----------------------------------------------------
// internal/database/db.go
//-----------------------------------------------------
package database

import (
Â Â Â  "context"
Â Â Â  "database/sql"
Â Â Â  "fmt"
Â Â Â  "time"

Â Â Â  "github.com/rs/zerolog/log"
Â Â Â  "github.com/yourusername/leetgrind-bot/config"

Â Â Â  // Database drivers
Â Â Â  _ "github.com/mattn/go-sqlite3"
)

// DB represents a database connection
type DB struct {
Â Â Â  *sql.DB
Â Â Â  config config.DatabaseConfig
}

// New creates a new database connection
func New(ctx context.Context, cfg config.DatabaseConfig) (*DB, error) {
Â Â Â  // Open database connection
Â Â Â  db, err := sql.Open(cfg.Driver, cfg.DSN)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to open database: %w", err)
Â Â Â  }

Â Â Â  // Configure connection pool
Â Â Â  db.SetMaxOpenConns(cfg.MaxOpenConns)
Â Â Â  db.SetMaxIdleConns(cfg.MaxIdleConns)
Â Â Â  db.SetConnMaxLifetime(cfg.ConnMaxLife)

Â Â Â  // Verify connection with timeout
Â Â Â  pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
Â Â Â  defer cancel()

Â Â Â  if err := db.PingContext(pingCtx); err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to ping database: %w", err)
Â Â Â  }

Â Â Â  log.Info().
Â Â Â Â Â Â Â  Str("driver", cfg.Driver).
Â Â Â Â Â Â Â  Str("dsn", maskDSN(cfg.DSN)).
Â Â Â Â Â Â Â  Int("max_conns", cfg.MaxOpenConns).
Â Â Â Â Â Â Â  Msg("Database connected successfully")

Â Â Â  return &DB{DB: db, config: cfg}, nil
}

// QueryContext executes a query with timeout from config
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
Â Â Â  queryCtx, cancel := context.WithTimeout(ctx, db.config.QueryTimeout)
Â Â Â  defer cancel()
Â Â Â  return db.DB.QueryContext(queryCtx, query, args...)
}

// ExecContext executes a statement with timeout from config
func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
Â Â Â  execCtx, cancel := context.WithTimeout(ctx, db.config.QueryTimeout)
Â Â Â  defer cancel()
Â Â Â  return db.DB.ExecContext(execCtx, query, args...)
}

// Begin starts a transaction with default options
func (db *DB) Begin(ctx context.Context) (*sql.Tx, error) {
Â Â Â  txCtx, cancel := context.WithTimeout(ctx, db.config.QueryTimeout)
Â Â Â  defer cancel()
Â Â Â  return db.DB.BeginTx(txCtx, nil)
}

// maskDSN hides sensitive information in DSN for logging
func maskDSN(dsn string) string {
Â Â Â  // For SQLite, just return the filename
Â Â Â  // For other databases, you'd want to mask passwords
Â Â Â  return dsn
}

//-----------------------------------------------------
// internal/database/migrations.go
//-----------------------------------------------------
package database

import (
Â Â Â  "context"
Â Â Â  "fmt"
Â Â Â  "os"
Â Â Â  "path/filepath"

Â Â Â  "github.com/rs/zerolog/log"
)

// Schema version
const currentVersion = 1

// Migrate runs database migrations to ensure schema is up to date
func Migrate(ctx context.Context, db *DB) error {
Â Â Â  // Create migration table if it doesn't exist
Â Â Â  _, err := db.ExecContext(ctx, `
Â Â Â Â Â Â Â  CREATE TABLE IF NOT EXISTS schema_migrations (
Â Â Â Â Â Â Â Â Â Â Â  version INTEGER PRIMARY KEY,
Â Â Â Â Â Â Â Â Â Â Â  applied_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
Â Â Â Â Â Â Â  )
Â Â Â  `)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to create migration table: %w", err)
Â Â Â  }

Â Â Â  // Get current schema version
Â Â Â  var version int
Â Â Â  err = db.QueryRowContext(ctx, `SELECT COALESCE(MAX(version), 0) FROM schema_migrations`).Scan(&version)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to get schema version: %w", err)
Â Â Â  }

Â Â Â  log.Info().Int("current_version", version).Int("target_version", currentVersion).Msg("Checking database migrations")

Â Â Â  // Apply migrations if needed
Â Â Â  if version < currentVersion {
Â Â Â Â Â Â Â  log.Info().Msg("Running database migrations")
Â Â Â Â Â Â Â  if err := runMigrations(ctx, db, version); err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return err
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  return nil
}

// runMigrations applies all necessary migrations in sequence
func runMigrations(ctx context.Context, db *DB, currentVersion int) error {
Â Â Â  // Start a transaction for all migrations
Â Â Â  tx, err := db.Begin(ctx)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to start transaction: %w", err)
Â Â Â  }
Â Â Â  defer tx.Rollback()

Â Â Â  // Apply each migration in sequence
Â Â Â  for v := currentVersion + 1; v <= currentVersion; v++ {
Â Â Â Â Â Â Â  log.Info().Int("version", v).Msg("Applying migration")
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â  switch v {
Â Â Â Â Â Â Â  case 1:
Â Â Â Â Â Â Â Â Â Â Â  if err := migrateV1(ctx, tx); err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return err
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  // Add future migrations here
Â Â Â Â Â Â Â  default:
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("unknown migration version: %d", v)
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Update schema version
Â Â Â Â Â Â Â  _, err = tx.ExecContext(ctx, `INSERT INTO schema_migrations (version) VALUES (?)`, v)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to update schema version: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  // Commit all migrations
Â Â Â  if err := tx.Commit(); err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to commit migrations: %w", err)
Â Â Â  }

Â Â Â  log.Info().Int("version", currentVersion).Msg("Database schema is up to date")
Â Â Â  return nil
}

// Migration to create initial schema
func migrateV1(ctx context.Context, tx *sql.Tx) error {
Â Â Â  // Create problems table
Â Â Â  _, err := tx.ExecContext(ctx, `
Â Â Â  CREATE TABLE IF NOT EXISTS problems (
Â Â Â Â Â Â Â  id INTEGER PRIMARY KEY AUTOINCREMENT,
Â Â Â Â Â Â Â  user_id TEXT NOT NULL,
Â Â Â Â Â Â Â  problem_name TEXT NOT NULL,
Â Â Â Â Â Â Â  link TEXT,
Â Â Â Â Â Â Â  difficulty TEXT NOT NULL,
Â Â Â Â Â Â Â  category TEXT NOT NULL,
Â Â Â Â Â Â Â  status TEXT NOT NULL,
Â Â Â Â Â Â Â  solved_at TIMESTAMP NOT NULL,
Â Â Â Â Â Â Â  last_reviewed_at TIMESTAMP,
Â Â Â Â Â Â Â  review_count INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  notes TEXT
Â Â Â  )`)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to create problems table: %w", err)
Â Â Â  }

Â Â Â  // Create tags table
Â Â Â  _, err = tx.ExecContext(ctx, `
Â Â Â  CREATE TABLE IF NOT EXISTS tags (
Â Â Â Â Â Â Â  id INTEGER PRIMARY KEY AUTOINCREMENT,
Â Â Â Â Â Â Â  name TEXT NOT NULL UNIQUE
Â Â Â  )`)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to create tags table: %w", err)
Â Â Â  }

Â Â Â  // Create problem_tags table (many-to-many)
Â Â Â  _, err = tx.ExecContext(ctx, `
Â Â Â  CREATE TABLE IF NOT EXISTS problem_tags (
Â Â Â Â Â Â Â  problem_id INTEGER NOT NULL,
Â Â Â Â Â Â Â  tag_id INTEGER NOT NULL,
Â Â Â Â Â Â Â  PRIMARY KEY (problem_id, tag_id),
Â Â Â Â Â Â Â  FOREIGN KEY (problem_id) REFERENCES problems(id) ON DELETE CASCADE,
Â Â Â Â Â Â Â  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
Â Â Â  )`)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to create problem_tags table: %w", err)
Â Â Â  }

Â Â Â  // Create user_stats table for aggregated metrics
Â Â Â  _, err = tx.ExecContext(ctx, `
Â Â Â  CREATE TABLE IF NOT EXISTS user_stats (
Â Â Â Â Â Â Â  user_id TEXT PRIMARY KEY,
Â Â Â Â Â Â Â  total_solved INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  total_needed_hint INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  total_stuck INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  easy_count INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  medium_count INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  hard_count INTEGER NOT NULL DEFAULT 0,
Â Â Â Â Â Â Â  last_active_at TIMESTAMP
Â Â Â  )`)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to create user_stats table: %w", err)
Â Â Â  }

Â Â Â  // Create indices for common queries
Â Â Â  queries := []string{
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problems_user_id ON problems(user_id)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problems_status ON problems(status)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problems_solved_at ON problems(solved_at)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problems_difficulty ON problems(difficulty)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problems_category ON problems(category)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problems_status_solved_at ON problems(status, solved_at)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problem_tags_problem_id ON problem_tags(problem_id)`,
Â Â Â Â Â Â Â  `CREATE INDEX IF NOT EXISTS idx_problem_tags_tag_id ON problem_tags(tag_id)`,
Â Â Â  }

Â Â Â  for _, query := range queries {
Â Â Â Â Â Â Â  if _, err := tx.ExecContext(ctx, query); err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to create index: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  return nil
}
// internal/database/models.go
//-----------------------------------------------------
package database

import (
Â Â Â  "context"
Â Â Â  "database/sql"
Â Â Â  "errors"
Â Â Â  "fmt"
Â Â Â  "strings"
Â Â Â  "time"

Â Â Â  "github.com/rs/zerolog/log"
)

// Problem status constants
const (
Â Â Â  StatusSolvedÂ Â Â Â Â  = "Solved"
Â Â Â  StatusNeededHint = "Needed Hint"
Â Â Â  StatusStuckÂ Â Â Â Â Â  = "Stuck"
)

// Difficulty constants
const (
Â Â Â  DifficultyEasyÂ Â  = "Easy"
Â Â Â  DifficultyMedium = "Medium"
Â Â Â  DifficultyHardÂ Â  = "Hard"
)

// ProblemEntry represents a solved problem
type ProblemEntry struct {
Â Â Â  IDÂ Â Â Â Â Â Â Â Â Â Â Â  intÂ Â Â Â Â Â Â  `json:"id"`
Â Â Â  UserIDÂ Â Â Â Â Â Â Â  stringÂ Â Â Â  `json:"user_id"`
Â Â Â  ProblemNameÂ Â Â  stringÂ Â Â Â  `json:"problem_name"`
Â Â Â  LinkÂ Â Â Â Â Â Â Â Â Â  stringÂ Â Â Â  `json:"link"`
Â Â Â  DifficultyÂ Â Â Â  stringÂ Â Â Â  `json:"difficulty"`
Â Â Â  CategoryÂ Â Â Â Â Â  stringÂ Â Â Â  `json:"category"`
Â Â Â  StatusÂ Â Â Â Â Â Â Â  stringÂ Â Â Â  `json:"status"`
Â Â Â  SolvedAtÂ Â Â Â Â Â  time.TimeÂ  `json:"solved_at"`
Â Â Â  LastReviewedAt *time.Time `json:"last_reviewed_at"`
Â Â Â  ReviewCountÂ Â Â  intÂ Â Â Â Â Â Â  `json:"review_count"`
Â Â Â  NotesÂ Â Â Â Â Â Â Â Â  stringÂ Â Â Â  `json:"notes"`
Â Â Â  TagsÂ Â Â Â Â Â Â Â Â  stringÂ Â  `json:"tags"`
}

// UserStats represents aggregated stats for a user
type UserStats struct {
Â Â Â  UserIDÂ Â Â Â Â Â Â Â Â  stringÂ Â Â Â  `json:"user_id"`
Â Â Â  TotalSolvedÂ Â Â Â  intÂ Â Â Â Â Â Â  `json:"total_solved"`
Â Â Â  TotalNeededHint intÂ Â Â Â Â Â Â  `json:"total_needed_hint"`
Â Â Â  TotalStuckÂ Â Â Â Â  intÂ Â Â Â Â Â Â  `json:"total_stuck"`
Â Â Â  EasyCountÂ Â Â Â Â Â  intÂ Â Â Â Â Â Â  `json:"easy_count"`
Â Â Â  MediumCountÂ Â Â Â  intÂ Â Â Â Â Â Â  `json:"medium_count"`
Â Â Â  HardCountÂ Â Â Â Â Â  intÂ Â Â Â Â Â Â  `json:"hard_count"`
Â Â Â  LastActiveAtÂ Â Â  *time.Time `json:"last_active_at"`
}

// ValidateProblemEntry validates a problem entry
func ValidateProblemEntry(p *ProblemEntry) error {
Â Â Â  if p.UserID == "" {
Â Â Â Â Â Â Â  return errors.New("user ID is required")
Â Â Â  }
Â Â Â  if p.ProblemName == "" {
Â Â Â Â Â Â Â  return errors.New("problem name is required")
Â Â Â  }
Â Â Â  if p.Difficulty != DifficultyEasy && p.Difficulty != DifficultyMedium && p.Difficulty != DifficultyHard {
Â Â Â Â Â Â Â  return fmt.Errorf("invalid difficulty: %s", p.Difficulty)
Â Â Â  }
Â Â Â  if p.Status != StatusSolved && p.Status != StatusNeededHint && p.Status != StatusStuck {
Â Â Â Â Â Â Â  return fmt.Errorf("invalid status: %s", p.Status)
Â Â Â  }
Â Â Â  if p.Category == "" {
Â Â Â Â Â Â Â  return errors.New("category is required")
Â Â Â  }
Â Â Â  return nil
}

// InsertProblem inserts a new problem entry with transaction support
func (db *DB) InsertProblem(ctx context.Context, p *ProblemEntry) error {
Â Â Â  if err := ValidateProblemEntry(p); err != nil {
Â Â Â Â Â Â Â  return err
Â Â Â  }

Â Â Â  // Start transaction
Â Â Â  tx, err := db.Begin(ctx)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to start transaction: %w", err)
Â Â Â  }
Â Â Â  defer tx.Rollback()

Â Â Â  // Insert problem
Â Â Â  query := `
Â Â Â  INSERT INTO problems (
Â Â Â Â Â Â Â  user_id, problem_name, link, difficulty, category, status, solved_at, notes
Â Â Â  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
Â Â Â  RETURNING id
Â Â Â  `

Â Â Â  // For SQLite which might not support RETURNING
Â Â Â  var result sql.Result
Â Â Â  var problemID int

Â Â Â  if db.config.Driver == "sqlite3" {
Â Â Â Â Â Â Â  result, err = tx.ExecContext(ctx, `
Â Â Â Â Â Â Â  INSERT INTO problems (
Â Â Â Â Â Â Â Â Â Â Â  user_id, problem_name, link, difficulty, category, status, solved_at, notes
Â Â Â Â Â Â Â  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
Â Â Â Â Â Â Â Â Â Â Â  p.UserID, p.ProblemName, p.Link, p.Difficulty, p.Category, p.Status, p.SolvedAt, p.Notes)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to insert problem: %w", err)
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Get last inserted ID
Â Â Â Â Â Â Â  lastID, err := result.LastInsertId()
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to get last insert ID: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  problemID = int(lastID)
Â Â Â  } else {
Â Â Â Â Â Â Â  // For databases supporting RETURNING
Â Â Â Â Â Â Â  err = tx.QueryRowContext(ctx, query,
Â Â Â Â Â Â Â Â Â Â Â  p.UserID, p.ProblemName, p.Link, p.Difficulty, p.Category, p.Status, p.SolvedAt, p.Notes).Scan(&problemID)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to insert problem: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  // Insert tags if any
Â Â Â  if len(p.Tags) > 0 {
Â Â Â Â Â Â Â  for _, tag := range p.Tags {
Â Â Â Â Â Â Â Â Â Â Â  tag = strings.TrimSpace(tag)
Â Â Â Â Â Â Â Â Â Â Â  if tag == "" {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  continue
Â Â Â Â Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â Â Â Â Â  // Insert tag if not exists
Â Â Â Â Â Â Â Â Â Â Â  var tagID int
Â Â Â Â Â Â Â Â Â Â Â  err := tx.QueryRowContext(ctx, `
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  INSERT INTO tags (name) VALUES (?)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ON CONFLICT (name) DO UPDATE SET name=name
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  RETURNING id`,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  tag).Scan(&tagID)

Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Try alternative approach for SQLite
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if db.config.Driver == "sqlite3" {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Check if tag exists
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  err = tx.QueryRowContext(ctx, `SELECT id FROM tags WHERE name = ?`, tag).Scan(&tagID)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if errors.Is(err, sql.ErrNoRows) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Insert new tag
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  res, err := tx.ExecContext(ctx, `INSERT INTO tags (name) VALUES (?)`, tag)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to insert tag: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lastID, err := res.LastInsertId()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to get tag ID: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  tagID = int(lastID)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to check tag existence: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to upsert tag: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â Â Â Â Â  // Link problem to tag
Â Â Â Â Â Â Â Â Â Â Â  _, err = tx.ExecContext(ctx, `
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  INSERT INTO problem_tags (problem_id, tag_id) VALUES (?, ?)`,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  problemID, tagID)
Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to link problem to tag: %w", err)
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  // Update user stats
Â Â Â  err = updateUserStats(ctx, tx, p)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to update user stats: %w", err)
Â Â Â  }

Â Â Â  // Commit transaction
Â Â Â  if err := tx.Commit(); err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to commit transaction: %w", err)
Â Â Â  }

Â Â Â  // Update the ID in the struct
Â Â Â  p.ID = problemID
Â Â Â  return nil
}

// updateUserStats updates user statistics based on the new problem
func updateUserStats(ctx context.Context, tx *sql.Tx, p *ProblemEntry) error {
Â Â Â  now := time.Now()

Â Â Â  // Check if user stats exist
Â Â Â  var exists bool
Â Â Â  err := tx.QueryRowContext(ctx, `SELECT EXISTS(SELECT 1 FROM user_stats WHERE user_id = ?)`, p.UserID).Scan(&exists)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to check user stats existence: %w", err)
Â Â Â  }

Â Â Â  if !exists {
Â Â Â Â Â Â Â  // Create new user stats
Â Â Â Â Â Â Â  _, err = tx.ExecContext(ctx, `
Â Â Â Â Â Â Â Â Â Â Â  INSERT INTO user_stats (
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  user_id, last_active_at
Â Â Â Â Â Â Â Â Â Â Â  ) VALUES (?, ?)`,
Â Â Â Â Â Â Â Â Â Â Â  p.UserID, now)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to create user stats: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â  }

Â Â Â  // Prepare the update statement based on problem properties
Â Â Â  var updatesstring
Â Â Â  var argsinterface{}

Â Â Â  // Update counters based on status
Â Â Â  switch p.Status {
Â Â Â  case StatusSolved:
Â Â Â Â Â Â Â  updates = append(updates, "total_solved = total_solved + 1")
Â Â Â  case StatusNeededHint:
Â Â Â Â Â Â Â  updates = append(updates, "total_needed_hint = total_needed_hint + 1")
Â Â Â  case StatusStuck:
Â Â Â Â Â Â Â  updates = append(updates, "total_stuck = total_stuck + 1")
Â Â Â  }

Â Â Â  // Update counters based on difficulty
Â Â Â  switch p.Difficulty {
Â Â Â  case DifficultyEasy:
Â Â Â Â Â Â Â  updates = append(updates, "easy_count = easy_count + 1")
Â Â Â  case DifficultyMedium:
Â Â Â Â Â Â Â  updates = append(updates, "medium_count = medium_count + 1")
Â Â Â  case DifficultyHard:
Â Â Â Â Â Â Â  updates = append(updates, "hard_count = hard_count + 1")
Â Â Â  }

Â Â Â  // Always update last active timestamp
Â Â Â  updates = append(updates, "last_active_at = ?")
Â Â Â  args = append(args, now)

Â Â Â  // Add WHERE clause
Â Â Â  args = append(args, p.UserID)

Â Â Â  // Execute the update
Â Â Â  query := fmt.Sprintf(`
Â Â Â Â Â Â Â  UPDATE user_stats
Â Â Â Â Â Â Â  SET %s
Â Â Â Â Â Â Â  WHERE user_id = ?`, strings.Join(updates, ", "))

Â Â Â  _, err = tx.ExecContext(ctx, query, args...)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to update user stats: %w", err)
Â Â Â  }

Â Â Â  return nil
}

// GetProblem fetches a problem by ID
func (db *DB) GetProblem(ctx context.Context, id int) (*ProblemEntry, error) {
Â Â Â  query := `
Â Â Â  SELECT id, user_id, problem_name, link, difficulty, category, status,
Â Â Â Â Â Â Â Â Â Â  solved_at, last_reviewed_at, review_count, notes
Â Â Â  FROM problems
Â Â Â  WHERE id = ?
Â Â Â  `

Â Â Â  var p ProblemEntry
Â Â Â  var solvedAt string
Â Â Â  var lastReviewedAt sql.NullString

Â Â Â  err := db.QueryRowContext(ctx, query, id).Scan(
Â Â Â Â Â Â Â  &p.ID, &p.UserID, &p.ProblemName, &p.Link,
Â Â Â Â Â Â Â  &p.Difficulty, &p.Category, &p.Status, &solvedAt,
Â Â Â Â Â Â Â  &lastReviewedAt, &p.ReviewCount, &p.Notes,
Â Â Â  )
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  if errors.Is(err, sql.ErrNoRows) {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("problem not found: %d", id)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to fetch problem: %w", err)
Â Â Â  }

Â Â Â  // Parse timestamps
Â Â Â  parsedTime, err := time.Parse("2006-01-02 15:04:05", solvedAt)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse solved_at time: %w", err)
Â Â Â  }
Â Â Â  p.SolvedAt = parsedTime

Â Â Â  if lastReviewedAt.Valid {
Â Â Â Â Â Â Â  reviewedTime, err := time.Parse("2006-01-02 15:04:05", lastReviewedAt.String)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse last_reviewed_at time: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  p.LastReviewedAt = &reviewedTime
Â Â Â  }

Â Â Â  // Fetch tags
Â Â Â  p.Tags, err = db.GetProblemTags(ctx, p.ID)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to get problem tags: %w", err)
Â Â Â  }

Â Â Â  return &p, nil
}

// GetProblemTags fetches tags associated with a problem ID
func (db *DB) GetProblemTags(ctx context.Context, problemID int) (string, error) {
Â Â Â  query := `
Â Â Â  SELECT t.name
Â Â Â  FROM problem_tags pt
Â Â Â  JOIN tags t ON pt.tag_id = t.id
Â Â Â  WHERE pt.problem_id = ?
Â Â Â  `

Â Â Â  rows, err := db.QueryContext(ctx, query, problemID)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to query problem tags: %w", err)
Â Â Â  }
Â Â Â  defer rows.Close()

Â Â Â  var tagsstring
Â Â Â  for rows.Next() {
Â Â Â Â Â Â Â  var tag string
Â Â Â Â Â Â Â  if err := rows.Scan(&tag); err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to scan tag: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  tags = append(tags, tag)
Â Â Â  }

Â Â Â  if err := rows.Err(); err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("error iterating over tags: %w", err)
Â Â Â  }

Â Â Â  return tags, nil
}

// UpdateProblem updates an existing problem entry
func (db *DB) UpdateProblem(ctx context.Context, p *ProblemEntry) error {
Â Â Â  if err := ValidateProblemEntry(p); err != nil {
Â Â Â Â Â Â Â  return err
Â Â Â  }

Â Â Â  // Start transaction
Â Â Â  tx, err := db.Begin(ctx)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to start transaction: %w", err)
Â Â Â  }
Â Â Â  defer tx.Rollback()

Â Â Â  query := `
Â Â Â  UPDATE problems
Â Â Â  SET user_id = ?,
Â Â Â Â Â Â Â  problem_name = ?,
Â Â Â Â Â Â Â  link = ?,
Â Â Â Â Â Â Â  difficulty = ?,
Â Â Â Â Â Â Â  category = ?,
Â Â Â Â Â Â Â  status = ?,
Â Â Â Â Â Â Â  solved_at = ?,
Â Â Â Â Â Â Â  last_reviewed_at = ?,
Â Â Â Â Â Â Â  review_count = ?,
Â Â Â Â Â Â Â  notes = ?
Â Â Â  WHERE id = ?
Â Â Â  `

Â Â Â  _, err = tx.ExecContext(ctx, query,
Â Â Â Â Â Â Â  p.UserID, p.ProblemName, p.Link, p.Difficulty, p.Category, p.Status,
Â Â Â Â Â Â Â  p.SolvedAt, p.LastReviewedAt, p.ReviewCount, p.Notes, p.ID)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to update problem: %w", err)
Â Â Â  }

Â Â Â  // Update tags
Â Â Â  if err := db.updateProblemTags(ctx, tx, p.ID, p.Tags); err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to update problem tags: %w", err)
Â Â Â  }

Â Â Â  // Commit transaction
Â Â Â  if err := tx.Commit(); err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to commit transaction: %w", err)
Â Â Â  }

Â Â Â  return nil
}

// updateProblemTags updates the tags associated with a problem
func (db *DB) updateProblemTags(ctx context.Context, tx *sql.Tx, problemID int, tagsstring) error {
Â Â Â  // Delete existing tags for the problem
Â Â Â  _, err := tx.ExecContext(ctx, `DELETE FROM problem_tags WHERE problem_id = ?`, problemID)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to delete existing problem tags: %w", err)
Â Â Â  }

Â Â Â  // Insert new tags
Â Â Â  for _, tag := range tags {
Â Â Â Â Â Â Â  tag = strings.TrimSpace(tag)
Â Â Â Â Â Â Â  if tag == "" {
Â Â Â Â Â Â Â Â Â Â Â  continue
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  var tagID int
Â Â Â Â Â Â Â  err := tx.QueryRowContext(ctx, `
Â Â Â Â Â Â Â Â Â Â Â  INSERT INTO tags (name) VALUES (?)
Â Â Â Â Â Â Â Â Â Â Â  ON CONFLICT (name) DO UPDATE SET name=name
Â Â Â Â Â Â Â Â Â Â Â  RETURNING id`,
Â Â Â Â Â Â Â Â Â Â Â  tag).Scan(&tagID)

Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  // Try alternative approach for SQLite
Â Â Â Â Â Â Â Â Â Â Â  if db.config.Driver == "sqlite3" {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Check if tag exists
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  err = tx.QueryRowContext(ctx, `SELECT id FROM tags WHERE name = ?`, tag).Scan(&tagID)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if errors.Is(err, sql.ErrNoRows) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Insert new tag
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  res, err := tx.ExecContext(ctx, `INSERT INTO tags (name) VALUES (?)`, tag)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to insert tag: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lastID, err := res.LastInsertId()
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to get tag ID: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  tagID = int(lastID)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to check tag existence: %w", err)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to upsert tag: %w", err)
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Link problem to tag
Â Â Â Â Â Â Â  _, err = tx.ExecContext(ctx, `
Â Â Â Â Â Â Â Â Â Â Â  INSERT INTO problem_tags (problem_id, tag_id) VALUES (?, ?)`,
Â Â Â Â Â Â Â Â Â Â Â  problemID, tagID)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return fmt.Errorf("failed to link problem to tag: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â  }
Â Â Â  return nil
}

// DeleteProblem deletes a problem by ID
func (db *DB) DeleteProblem(ctx context.Context, id int) error {
Â Â Â  tx, err := db.Begin(ctx)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to start transaction: %w", err)
Â Â Â  }
Â Â Â  defer tx.Rollback()

Â Â Â  _, err = tx.ExecContext(ctx, `DELETE FROM problems WHERE id = ?`, id)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to delete problem: %w", err)
Â Â Â  }

Â Â Â  // Optionally delete orphaned tags (tags with no associated problems)
Â Â Â  // This can be done with a separate query if needed.

Â Â Â  return tx.Commit()
}

// ListProblems retrieves a list of problems based on filters
func (db *DB) ListProblems(ctx context.Context, userID string, status string, difficulty string, category string, tagsstring, limit int, offset int) (*ProblemEntry, error) {
Â Â Â  var conditionsstring
Â Â Â  var argsinterface{}

Â Â Â  if userID != "" {
Â Â Â Â Â Â Â  conditions = append(conditions, "user_id = ?")
Â Â Â Â Â Â Â  args = append(args, userID)
Â Â Â  }
Â Â Â  if status != "" {
Â Â Â Â Â Â Â  conditions = append(conditions, "status = ?")
Â Â Â Â Â Â Â  args = append(args, status)
Â Â Â  }
Â Â Â  if difficulty != "" {
Â Â Â Â Â Â Â  conditions = append(conditions, "difficulty = ?")
Â Â Â Â Â Â Â  args = append(args, difficulty)
Â Â Â  }
Â Â Â  if category != "" {
Â Â Â Â Â Â Â  conditions = append(conditions, "category = ?")
Â Â Â Â Â Â Â  args = append(args, category)
Â Â Â  }

Â Â Â  query := `
Â Â Â  SELECT p.id, p.user_id, p.problem_name, p.link, p.difficulty, p.category, p.status,
Â Â Â Â Â Â Â Â Â Â  p.solved_at, p.last_reviewed_at, p.review_count, p.notes
Â Â Â  FROM problems p
Â Â Â  `

Â Â Â  if len(tags) > 0 {
Â Â Â Â Â Â Â  query += `
Â Â Â Â Â Â Â  JOIN problem_tags pt ON p.id = pt.problem_id
Â Â Â Â Â Â Â  JOIN tags t ON pt.tag_id = t.id
Â Â Â Â Â Â Â  WHERE t.name IN (` + strings.Join(strings.Split(strings.Repeat("?", len(tags)), ""), ", ") + `)
Â Â Â Â Â Â Â  `
Â Â Â Â Â Â Â  for _, tag := range tags {
Â Â Â Â Â Â Â Â Â Â Â  args = append(args, tag)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  if len(conditions) > 0 {
Â Â Â Â Â Â Â Â Â Â Â  query += " AND " + strings.Join(conditions, " AND ")
Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â  // Need to handle the case where there are tags but no other conditions
Â Â Â Â Â Â Â Â Â Â Â  // The WHERE clause is already added for tags.
Â Â Â Â Â Â Â  }
Â Â Â  } else if len(conditions) > 0 {
Â Â Â Â Â Â Â  query += "WHERE " + strings.Join(conditions, " AND ")
Â Â Â  }

Â Â Â  query += ` ORDER BY solved_at DESC`

Â Â Â  if limit > 0 {
Â Â Â Â Â Â Â  query += ` LIMIT ?`
Â Â Â Â Â Â Â  args = append(args, limit)
Â Â Â  }
Â Â Â  if offset > 0 {
Â Â Â Â Â Â Â  query += ` OFFSET ?`
Â Â Â Â Â Â Â  args = append(args, offset)
Â Â Â  }

Â Â Â  rows, err := db.QueryContext(ctx, query, args...)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to list problems: %w", err)
Â Â Â  }
Â Â Â  defer rows.Close()

Â Â Â  var problems*ProblemEntry
Â Â Â  for rows.Next() {
Â Â Â Â Â Â Â  var p ProblemEntry
Â Â Â Â Â Â Â  var solvedAt string
Â Â Â Â Â Â Â  var lastReviewedAt sql.NullString

Â Â Â Â Â Â Â  err := rows.Scan(
Â Â Â Â Â Â Â Â Â Â Â  &p.ID, &p.UserID, &p.ProblemName, &p.Link,
Â Â Â Â Â Â Â Â Â Â Â  &p.Difficulty, &p.Category, &p.Status, &solvedAt,
Â Â Â Â Â Â Â Â Â Â Â  &lastReviewedAt, &p.ReviewCount, &p.Notes,
Â Â Â Â Â Â Â  )
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to scan problem: %w", err)
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Parse timestamps
Â Â Â Â Â Â Â  parsedTime, err := time.Parse("2006-01-02 15:04:05", solvedAt)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse solved_at time: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  p.SolvedAt = parsedTime

Â Â Â Â Â Â Â  if lastReviewedAt.Valid {
Â Â Â Â Â Â Â Â Â Â Â  reviewedTime, err := time.Parse("2006-01-02 15:04:05", lastReviewedAt.String)
Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse last_reviewed_at time: %w", err)
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  p.LastReviewedAt = &reviewedTime
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Fetch tags for each problem
Â Â Â Â Â Â Â  p.Tags, err = db.GetProblemTags(ctx, p.ID)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  log.Error().Err(err).Int("problem_id", p.ID).Msg("Failed to get tags for problem")
Â Â Â Â Â Â Â Â Â Â Â  // Continue with the problem entry even if tags fail to load
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  problems = append(problems, &p)
Â Â Â  }

Â Â Â  if err := rows.Err(); err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("error iterating over problems: %w", err)
Â Â Â  }

Â Â Â  return problems, nil
}

// GetUserStats retrieves user statistics
func (db *DB) GetUserStats(ctx context.Context, userID string) (*UserStats, error) {
Â Â Â  query := `
Â Â Â  SELECT user_id, total_solved, total_needed_hint, total_stuck, easy_count, medium_count, hard_count, last_active_at
Â Â Â  FROM user_stats
Â Â Â  WHERE user_id = ?
Â Â Â  `

Â Â Â  var stats UserStats
Â Â Â  var lastActiveAt sql.NullString

Â Â Â  err := db.QueryRowContext(ctx, query, userID).Scan(
Â Â Â Â Â Â Â  &stats.UserID, &stats.TotalSolved, &stats.TotalNeededHint, &stats.TotalStuck,
Â Â Â Â Â Â Â  &stats.EasyCount, &stats.MediumCount, &stats.HardCount, &lastActiveAt,
Â Â Â  )
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  if errors.Is(err, sql.ErrNoRows) {
Â Â Â Â Â Â Â Â Â Â Â  return nil, nil // User stats not found, return nil
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to get user stats: %w", err)
Â Â Â  }

Â Â Â  if lastActiveAt.Valid {
Â Â Â Â Â Â Â  parsedTime, err := time.Parse("2006-01-02 15:04:05", lastActiveAt.String)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse last_active_at time: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  stats.LastActiveAt = &parsedTime
Â Â Â  }

Â Â Â  return &stats, nil
}

// UpdateUserLastActive updates the last active timestamp for a user
func (db *DB) UpdateUserLastActive(ctx context.Context, userID string) error {
Â Â Â  now := time.Now()
Â Â Â  _, err := db.ExecContext(ctx, `
Â Â Â Â Â Â Â  UPDATE user_stats
Â Â Â Â Â Â Â  SET last_active_at = ?
Â Â Â Â Â Â Â  WHERE user_id = ?`,
Â Â Â Â Â Â Â  now, userID)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to update last active time: %w", err)
Â Â Â  }
Â Â Â  return nil
}

// ListProblemsForReview retrieves problems that need to be reviewed based on the lookback period
func (db *DB) ListProblemsForReview(ctx context.Context, userID string, lookbackPeriod time.Duration) (*ProblemEntry, error) {
Â Â Â  cutoff := time.Now().Add(-lookbackPeriod)
Â Â Â  query := `
Â Â Â  SELECT id, user_id, problem_name, link, difficulty, category, status,
Â Â Â Â Â Â Â Â Â Â  solved_at, last_reviewed_at, review_count, notes
Â Â Â  FROM problems
Â Â Â  WHERE user_id = ? AND solved_at <= ? AND (last_reviewed_at IS NULL OR last_reviewed_at <= ?)
Â Â Â  ORDER BY solved_at ASC
Â Â Â  `

Â Â Â  rows, err := db.QueryContext(ctx, query, userID, cutoff, cutoff)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to list problems for review: %w", err)
Â Â Â  }
Â Â Â  defer rows.Close()

Â Â Â  var problems*ProblemEntry
Â Â Â  for rows.Next() {
Â Â Â Â Â Â Â  var p ProblemEntry
Â Â Â Â Â Â Â  var solvedAt string
Â Â Â Â Â Â Â  var lastReviewedAt sql.NullString

Â Â Â Â Â Â Â  err := rows.Scan(
Â Â Â Â Â Â Â Â Â Â Â  &p.ID, &p.UserID, &p.ProblemName, &p.Link,
Â Â Â Â Â Â Â Â Â Â Â  &p.Difficulty, &p.Category, &p.Status, &solvedAt,
Â Â Â Â Â Â Â Â Â Â Â  &lastReviewedAt, &p.ReviewCount, &p.Notes,
Â Â Â Â Â Â Â  )
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to scan problem: %w", err)
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Parse timestamps
Â Â Â Â Â Â Â  parsedTime, err := time.Parse("2006-01-02 15:04:05", solvedAt)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse solved_at time: %w", err)
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  p.SolvedAt = parsedTime

Â Â Â Â Â Â Â  if lastReviewedAt.Valid {
Â Â Â Â Â Â Â Â Â Â Â  reviewedTime, err := time.Parse("2006-01-02 15:04:05", lastReviewedAt.String)
Â Â Â Â Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return nil, fmt.Errorf("failed to parse last_reviewed_at time: %w", err)
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  p.LastReviewedAt = &reviewedTime
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  // Fetch tags for each problem
Â Â Â Â Â Â Â  p.Tags, err = db.GetProblemTags(ctx, p.ID)
Â Â Â Â Â Â Â  if err != nil {
Â Â Â Â Â Â Â Â Â Â Â  log.Error().Err(err).Int("problem_id", p.ID).Msg("Failed to get tags for review problem")
Â Â Â Â Â Â Â Â Â Â Â  // Continue even if tags fail to load
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  problems = append(problems, &p)
Â Â Â  }

Â Â Â  if err := rows.Err(); err != nil {
Â Â Â Â Â Â Â  return nil, fmt.Errorf("error iterating over review problems: %w", err)
Â Â Â  }

Â Â Â  return problems, nil
}

// IncrementReviewCount increments the review count and updates the last reviewed at timestamp
func (db *DB) IncrementReviewCount(ctx context.Context, problemID int) error {
Â Â Â  now := time.Now()
Â Â Â  _, err := db.ExecContext(ctx, `
Â Â Â Â Â Â Â  UPDATE problems
Â Â Â Â Â Â Â  SET review_count = review_count + 1,
Â Â Â Â Â Â Â Â Â Â Â  last_reviewed_at = ?
Â Â Â Â Â Â Â  WHERE id = ?`,
Â Â Â Â Â Â Â  now, problemID)
Â Â Â  if err != nil {
Â Â Â Â Â Â Â  return fmt.Errorf("failed to increment review count: %w", err)
Â Â Â  }
Â Â Â  return nil
}
//-----------------------------------------------------
// internal/bot/commands.go
//-----------------------------------------------------
package bot

import (
	"context"
	"fmt"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/rs/zerolog/log"
	"github.com/yourusername/leetgrind-bot/config"
	"github.com/yourusername/leetgrind-bot/internal/database"
)

// registerCommands registers the bot's commands with Discord
func (b *Bot) registerCommands(ctx context.Context) error {
	commands :=*discordgo.ApplicationCommand{
		{
			Name:        "add",
			Description: "Add a LeetCode problem you've solved",
			Options:*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "name",
					Description: "The name of the LeetCode problem",
					Required:    true,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "link",
					Description: "Optional link to the problem",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "difficulty",
					Description: "Difficulty of the problem",
					Required:    true,
					Choices:*discordgo.ApplicationCommandOptionChoice{
						{Name: database.DifficultyEasy, Value: database.DifficultyEasy},
						{Name: database.DifficultyMedium, Value: database.DifficultyMedium},
						{Name: database.DifficultyHard, Value: database.DifficultyHard},
					},
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "category",
					Description: "Category or topic of the problem",
					Required:    true,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "status",
					Description: "Status of the problem",
					Required:    true,
					Choices:*discordgo.ApplicationCommandOptionChoice{
						{Name: database.StatusSolved, Value: database.StatusSolved},
						{Name: database.StatusNeededHint, Value: database.StatusNeededHint},
						{Name: database.StatusStuck, Value: database.StatusStuck},
					},
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "solved_at",
					Description: "Date when you solved the problem (YYYY-MM-DD)",
					Required:    true,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "tags",
					Description: "Optional comma-separated tags for the problem",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "notes",
					Description: "Optional notes about the problem",
					Required:    false,
				},
			},
		},
		{
			Name:        "list",
			Description: "List your solved LeetCode problems",
			Options:*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "status",
					Description: "Filter by status",
					Required:    false,
					Choices:*discordgo.ApplicationCommandOptionChoice{
						{Name: database.StatusSolved, Value: database.StatusSolved},
						{Name: database.StatusNeededHint, Value: database.StatusNeededHint},
						{Name: database.StatusStuck, Value: database.StatusStuck},
					},
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "difficulty",
					Description: "Filter by difficulty",
					Required:    false,
					Choices:*discordgo.ApplicationCommandOptionChoice{
						{Name: database.DifficultyEasy, Value: database.DifficultyEasy},
						{Name: database.DifficultyMedium, Value: database.DifficultyMedium},
						{Name: database.DifficultyHard, Value: database.DifficultyHard},
					},
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "category",
					Description: "Filter by category",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "tags",
					Description: "Filter by comma-separated tags",
					Required:    false,
				},
			},
		},
		{
			Name:        "get",
			Description: "Get details of a solved problem by ID",
			Options:*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionInteger,
					Name:        "id",
					Description: "The ID of the problem",
					Required:    true,
				},
			},
		},
		{
			Name:        "edit",
			Description: "Edit an existing LeetCode problem",
			Options:*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionInteger,
					Name:        "id",
					Description: "The ID of the problem to edit",
					Required:    true,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "name",
					Description: "The name of the LeetCode problem",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "link",
					Description: "Optional link to the problem",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "difficulty",
					Description: "Difficulty of the problem",
					Required:    false,
					Choices:*discordgo.ApplicationCommandOptionChoice{
						{Name: database.DifficultyEasy, Value: database.DifficultyEasy},
						{Name: database.DifficultyMedium, Value: database.DifficultyMedium},
						{Name: database.DifficultyHard, Value: database.DifficultyHard},
					},
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "category",
					Description: "Category or topic of the problem",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "status",
					Description: "Status of the problem",
					Required:    false,
					Choices:*discordgo.ApplicationCommandOptionChoice{
						{Name: database.StatusSolved, Value: database.StatusSolved},
						{Name: database.StatusNeededHint, Value: database.StatusNeededHint},
						{Name: database.StatusStuck, Value: database.StatusStuck},
					},
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "solved_at",
					Description: "Date when you solved the problem (YYYY-MM-DD)",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "tags",
					Description: "Optional comma-separated tags for the problem",
					Required:    false,
				},
				{
					Type:        discordgo.ApplicationCommandOptionString,
					Name:        "notes",
					Description: "Optional notes about the problem",
					Required:    false,
				},
			},
		},
		{
			Name:        "delete",
			Description: "Delete a solved problem by ID",
			Options:*discordgo.ApplicationCommandOption{
				{
					Type:        discordgo.ApplicationCommandOptionInteger,
					Name:        "id",
					Description: "The ID of the problem to delete",
					Required:    true,
				},
			},
		},
		{
			Name:        "stats",
			Description: "View your LeetCode problem solving statistics",
		},
	}

	registeredCommands := make(*discordgo.ApplicationCommand, len(commands))
	for i, cmd := range commands {
		cmd.Version = "1.0.0" // Example version
		if b.cfg.Discord.GuildID == "" {
			registered, err := b.session.ApplicationCommandCreate(b.session.State.User.ID, "", cmd)
			if err != nil {
				return fmt.Errorf("failed to register global command '%s': %w", cmd.Name, err)
			}
			registeredCommands[i] = registered
			log.Info().Str("command", cmd.Name).Msg("Registered global command")
		} else {
			registered, err := b.session.ApplicationCommandCreate(b.session.State.User.ID, b.cfg.Discord.GuildID, cmd)
			if err != nil {
				return fmt.Errorf("failed to register guild command '%s': %w", cmd.Name, err)
			}
			registeredCommands[i] = registered
			log.Info().Str("command", cmd.Name).Str("guild_id", b.cfg.Discord.GuildID).Msg("Registered guild command")
		}
	}

	return nil
}

// deleteCommands deletes all registered commands (useful for development)
func (b *Bot) deleteCommands() {
	if b.cfg.Discord.GuildID == "" {
		cmds, err := b.session.ApplicationCommands(b.session.State.User.ID, "")
		if err != nil {
			log.Error().Err(err).Msg("Failed to get global commands")
			return
		}
		for _, cmd := range cmds {
			err := b.session.ApplicationCommandDelete(b.session.State.User.ID, "", cmd.ID)
			if err != nil {
				log.Error().Err(err).Str("command", cmd.Name).Msg("Failed to delete global command")
			} else {
				log.Info().Str("command", cmd.Name).Msg("Deleted global command")
			}
		}
	} else {
		cmds, err := b.session.ApplicationCommands(b.session.State.User.ID, b.cfg.Discord.GuildID)
		if err != nil {
			log.Error().Err(err).Str("guild_id", b.cfg.Discord.GuildID).Msg("Failed to get guild commands")
			return
		}
		for _, cmd := range cmds {
			err := b.session.ApplicationCommandDelete(b.session.State.User.ID, b.cfg.Discord.GuildID, cmd.ID)
			if err != nil {
				log.Error().Err(err).Str("command", cmd.Name).Str("guild_id", b.cfg.Discord.GuildID).Msg("Failed to delete guild command")
			} else {
				log.Info().Str("command", cmd.Name).Str("guild_id", b.cfg.Discord.GuildID).Msg("Deleted guild command")
			}
		}
	}
}

// interactionCreate is the handler for all incoming Discord interactions
func (b *Bot) interactionCreate(s *discordgo.Session, i *discordgo.InteractionCreate) {
	switch i.Type {
	case discordgo.InteractionApplicationCommand:
		resChan := make(chan *discordgo.InteractionResponse)
		errChan := make(chan error)
		timeout := time.NewTimer(b.cfg.Discord.CommandsTimeout)

		go func() {
			handler, ok := b.commandHandlers[i.ApplicationCommandData().Name]
			if !ok {
				errChan <- fmt.Errorf("unknown command: %s", i.ApplicationCommandData().Name)
				return
			}
			response, err := handler(s, i)
			if err != nil {
				errChan <- err
				return
			}
			resChan <- response
		}()

		select {
		case res := <-resChan:
			err := s.InteractionRespond(i.Interaction, res)
			if err != nil {
				log.Error().Err(err).Str("command", i.ApplicationCommandData().Name).Msg("Failed to respond to interaction")
			}
		case err := <-errChan:
			log.Error().Err(err).Str("command", i.ApplicationCommandData().Name).Msg("Error handling command")
			b.sendErrorResponse(s, i, "An error occurred while processing your command.")
		case <-timeout.C:
			log.Warn().Str("command", i.ApplicationCommandData().Name).Msg("Command timed out")
			b.sendErrorResponse(s, i, "Command processing timed out.")
		}
		timeout.Stop()
	}
}

func (b *Bot) sendErrorResponse(s *discordgo.Session, i *discordgo.InteractionCreate, message string) {
	err := s.InteractionRespond(i.Interaction, &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: message,
			Flags:   discordgo.MessageFlagsEphemeral,
		},
	})
	if err != nil {
		log.Error().Err(err).Msg("Failed to send error response")
	}
}

//-----------------------------------------------------
// internal/bot/handlers.go
//-----------------------------------------------------
package bot

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/bwmarrin/discordgo"
	"github.com/rs/zerolog/log"
	"github.com/yourusername/leetgrind-bot/internal/database"
)

// commandHandlers holds the mapping of command names to their handler functions
var (
	ErrInvalidDateFormat = fmt.Errorf("invalid date format, please use YYYY-MM-DD")
)

func (b *Bot) registerCommandHandlers() {
	b.commandHandlers = map[string]func(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error){
		"add":    b.handleAddCommand,
		"list":   b.handleListCommand,
		"get":    b.handleGetCommand,
		"edit":   b.handleEditCommand,
		"delete": b.handleDeleteCommand,
		"stats":  b.handleStatsCommand,
	}
}

func (b *Bot) handleAddCommand(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	options := i.ApplicationCommandData().Options
	optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
	for _, opt := range options {
		optionMap[opt.Name] = opt
	}

	solvedAtStr, ok := optionMap["solved_at"]
	if !ok || solvedAtStr.StringValue() == "" {
		return errorResponse("Missing or invalid solved_at date."), nil
	}
	solvedAt, err := time.Parse("2006-01-02", solvedAtStr.StringValue())
	if err != nil {
		return errorResponse(ErrInvalidDateFormat.Error()), nil
	}

	problem := &database.ProblemEntry{
		UserID:      i.Member.User.ID,
		ProblemName: optionMap["name"].StringValue(),
		Link:        optionMap["link"].StringValue(),
		Difficulty:  optionMap["difficulty"].StringValue(),
		Category:    optionMap["category"].StringValue(),
		Status:      optionMap["status"].StringValue(),
		SolvedAt:    solvedAt,
		Notes:       optionMap["notes"].StringValue(),
	}

	if tagsOpt, ok := optionMap["tags"]; ok && tagsOpt.StringValue() != "" {
		problem.Tags = tagsOpt.StringValue()
	}

	err = b.db.InsertProblem(context.Background(), problem)
	if err != nil {
		log.Error().Err(err).Msg("Failed to insert problem")
		return errorResponse("Failed to add problem to the database."), nil
	}

	return messageResponse(fmt.Sprintf("Successfully added problem '%s'!", problem.ProblemName)), nil
}

func (b *Bot) handleListCommand(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	options := i.ApplicationCommandData().Options
	optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
	for _, opt := range options {
		optionMap[opt.Name] = opt
	}

	status := ""
	if statusOpt, ok := optionMap["status"]; ok {
		status = statusOpt.StringValue()
	}
	difficulty := ""
	if difficultyOpt, ok := optionMap["difficulty"]; ok {
		difficulty = difficultyOpt.StringValue()
	}
	category := ""
	if categoryOpt, ok := optionMap["category"]; ok {
		category = categoryOpt.StringValue()
	}
	tags := ""
	if tagsOpt, ok := optionMap["tags"]; ok {
		tags = tagsOpt.StringValue()
	}

	problems, err := b.db.ListProblems(context.Background(), i.Member.User.ID, status, difficulty, category, tags, 0, 0)
	if err != nil {
		log.Error().Err(err).Msg("Failed to list problems")
		return errorResponse("Failed to retrieve your problem list."), nil
	}

	if len(problems) == 0 {
		return messageResponse("You haven't added any problems yet, or no problems match your filter."), nil
	}

	var sb strings.Builder
	sb.WriteString("Your Solved LeetCode Problems:\n")
	for _, p := range problems {
		sb.WriteString(fmt.Sprintf("- ID: %d, Name: %s, Difficulty: %s, Status: %s, Solved At: %s",
			p.ID, p.ProblemName, p.Difficulty, p.Status, p.SolvedAt.Format("2006-01-02")))
		if p.Tags != "" {
			sb.WriteString(fmt.Sprintf(", Tags: %s", p.Tags))
		}
		sb.WriteString("\n")
	}

	return messageResponse(sb.String()), nil
}

func (b *Bot) handleGetCommand(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	options := i.ApplicationCommandData().Options
	optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
	for _, opt := range options {
		optionMap[opt.Name] = opt
	}

	idOpt, ok := optionMap["id"]
	if !ok {
		return errorResponse("Missing problem ID."), nil
	}
	problemID := int(idOpt.IntValue())

	problem, err := b.db.GetProblem(context.Background(), problemID)
	if err != nil {
		log.Error().Err(err).Int("problem_id", problemID).Msg("Failed to get problem")
		return errorResponse(fmt.Sprintf("Could not find problem with ID %d.", problemID)), nil
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("Problem ID: %d\n", problem.ID))
	sb.WriteString(fmt.Sprintf("Name: %s\n", problem.ProblemName))
	if problem.Link != "" {
		sb.WriteString(fmt.Sprintf("Link: %s\n", problem.Link))
	}
	sb.WriteString(fmt.Sprintf("Difficulty: %s\n", problem.Difficulty))
	sb.WriteString(fmt.Sprintf("Category: %s\n", problem.Category))
	sb.WriteString(fmt.Sprintf("Status: %s\n", problem.Status))
	sb.WriteString(fmt.Sprintf("Solved At: %s\n", problem.SolvedAt.Format("2006-01-02")))
	if problem.LastReviewedAt != nil {
		sb.WriteString(fmt.Sprintf("Last Reviewed At: %s\n", problem.LastReviewedAt.Format("2006-01-02")))
	}
	sb.WriteString(fmt.Sprintf("Review Count: %d\n", problem.ReviewCount))
	if problem.Notes != "" {
		sb.WriteString(fmt.Sprintf("Notes: %s\n", problem.Notes))
	}
	if problem.Tags != "" {
		sb.WriteString(fmt.Sprintf("Tags: %s\n", problem.Tags))
	}

	return messageResponse(sb.String()), nil
}

func (b *Bot) handleEditCommand(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	options := i.ApplicationCommandData().Options
	optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
	for _, opt := range options {
		optionMap[opt.Name] = opt
	}

	idOpt, ok := optionMap["id"]
	if !ok {
		return errorResponse("Missing problem ID to edit."), nil
	}
	problemID := int(idOpt.IntValue())

	existingProblem, err := b.db.GetProblem(context.Background(), problemID)
	if err != nil {
		log.Error().Err(err).Int("problem_id", problemID).Msg("Failed to get problem for editing")
		return errorResponse(fmt.Sprintf("Could not find problem with ID %d to edit.", problemID)), nil
	}

	// Create a copy to avoid modifying the fetched problem directly
	updatedProblem := *existingProblem

	if nameOpt, ok := optionMap["name"]; ok {
		updatedProblem.ProblemName = nameOpt.StringValue()
	}
	if linkOpt, ok := optionMap["link"]; ok {
		updatedProblem.Link = linkOpt.StringValue()
	}
	if difficultyOpt, ok := optionMap["difficulty"]; ok {
		updatedProblem.Difficulty = difficultyOpt.StringValue()
	}
	if categoryOpt, ok := optionMap["category"]; ok {
		updatedProblem.Category = categoryOpt.StringValue()
	}
	if statusOpt, ok := optionMap["status"]; ok {
		updatedProblem.Status = statusOpt.StringValue()
	}
	if solvedAtOpt, ok := optionMap["solved_at"]; ok {
		solvedAt, err := time.Parse("2006-01-02", solvedAtOpt.StringValue())
		if err != nil {
			return errorResponse(ErrInvalidDateFormat.Error()), nil
		}
		updatedProblem.SolvedAt = solvedAt
	}
	if tagsOpt, ok := optionMap["tags"]; ok {
		updatedProblem.Tags = tagsOpt.StringValue()
	}
	if notesOpt, ok := optionMap["notes"]; ok {
		updatedProblem.Notes = notesOpt.StringValue()
	}

	updatedProblem.UserID = i.Member.User.ID // Ensure user ID is correct

	err = b.db.UpdateProblem(context.Background(), &updatedProblem)
	if err != nil {
		log.Error().Err(err).Int("problem_id", problemID).Msg("Failed to update problem")
		return errorResponse(fmt.Sprintf("Failed to update problem with ID %d.", problemID)), nil
	}

	return messageResponse(fmt.Sprintf("Successfully updated problem '%s' (ID: %d)!", updatedProblem.ProblemName, problemID)), nil
}

func (b *Bot) handleDeleteCommand(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	options := i.ApplicationCommandData().Options
	optionMap := make(map[string]*discordgo.ApplicationCommandInteractionDataOption, len(options))
	for _, opt := range options {
		optionMap[opt.Name] = opt
	}

	idOpt, ok := optionMap["id"]
	if !ok {
		return errorResponse("Missing problem ID to delete."), nil
	}
	problemID := int(idOpt.IntValue())

	err := b.db.DeleteProblem(context.Background(), problemID)
	if err != nil {
		log.Error().Err(err).Int("problem_id", problemID).Msg("Failed to delete problem")
		return errorResponse(fmt.Sprintf("Failed to delete problem with ID %d.", problemID)), nil
	}

	return messageResponse(fmt.Sprintf("Successfully deleted problem with ID %d!", problemID)), nil
}

func (b *Bot) handleStatsCommand(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	stats, err := b.db.GetUserStats(context.Background(), i.Member.User.ID)
	if err != nil {
		log.Error().Err(err).Msg("Failed to get user stats")
		return errorResponse("Failed to retrieve your statistics."), nil
	}

	if stats == nil {
		return messageResponse("No statistics found for you yet. Start adding problems!"), nil
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("Your LeetCode Statistics:\n"))
	sb.WriteString(fmt.Sprintf("Total Solved: %d\n", stats.TotalSolved))
	sb.WriteString(fmt.Sprintf("Needed Hint: %d\n", stats.TotalNeededHint))
	sb.WriteString(fmt.Sprintf("Stuck: %d\n", stats.TotalStuck))
	sb.WriteString(fmt.Sprintf("Easy: %d\n", stats.EasyCount))
	sb.WriteString(fmt.Sprintf("Medium: %d\n", stats.MediumCount))
	sb.WriteString(fmt.Sprintf("Hard: %d\n", stats.HardCount))
	if stats.LastActiveAt != nil {
		sb.WriteString(fmt.Sprintf("Last Active: %s\n", stats.LastActiveAt.Format("2006-01-02 15:04:05 MST")))
	}

	return messageResponse(sb.String()), nil
}

func messageResponse(content string) *discordgo.InteractionResponse {
	return &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: content,
		},
	}
}

func errorResponse(content string) *discordgo.InteractionResponse {
	return &discordgo.InteractionResponse{
		Type: discordgo.InteractionResponseChannelMessageWithSource,
		Data: &discordgo.InteractionResponseData{
			Content: content,
			Flags:   discordgo.MessageFlagsEphemeral,
		},
	}
}

//-----------------------------------------------------
// internal/bot/middleware.go
//-----------------------------------------------------
package bot

import (
	"github.com/bwmarrin/discordgo"
	"github.com/rs/zerolog/log"
)

// Middleware for handling errors during command execution.
// This is a placeholder and can be expanded with more sophisticated error handling.
func (b *Bot) errorMiddleware(next func(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error)) func(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
	return func(s *discordgo.Session, i *discordgo.InteractionCreate) (*discordgo.InteractionResponse, error) {
		response, err := next(s, i)
		if err != nil {
			log.Error().Err(err).Str("command", i.ApplicationCommandData().Name).Msg("Error during command execution")
			// Optionally send a user-friendly error message back to Discord
			return &discordgo.InteractionResponse{
				Type: discordgo.InteractionResponseChannelMessageWithSource,
				Data: &discordgo.InteractionResponseData{
					Content: "An unexpected error occurred while processing your command.",
					Flags:   discordgo.MessageFlagsEphemeral,
				},
			}, nil // Return nil error to prevent further propagation if already handled
		}
		return response, nil
	}
}

//-----------------------------------------------------
// internal/bot/scheduler.go
//-----------------------------------------------------
package bot

import (
	"context"
	"fmt"
	"time"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"
	"github.com/yourusername/leetgrind-bot/config"
)

// Scheduler manages the daily review reminders
type Scheduler struct {
	cron    *gocron.Scheduler
	bot     *Bot
	config  config.SchedulerConfig
	stop    chan bool
	running bool
}

// StartScheduler initializes and starts the daily review scheduler
func StartScheduler(ctx context.Context, b *Bot, cfg config.SchedulerConfig) *Scheduler {
	s := &Scheduler{
		cron:    gocron.NewScheduler(time.Local),
		bot:     b,
		config:  cfg,
		stop:    make(chan bool),
		running: false,
	}

	if _, err := s.cron.Every(1).Day().At(cfg.ReviewTime).Do(s.sendDailyReviewReminder, ctx); err != nil {
		log.Error().Err(err).Str("review_time", cfg.ReviewTime).Msg("Failed to schedule daily review reminder")
		return s
	}

	s.cron.StartAsync()
	s.running = true
	log.Info().Str("review_time", cfg.ReviewTime).Msg("Daily review scheduler started")
	return s
}

// Stop halts the scheduler
func (s *Scheduler) Stop() {
	if s.running {
		s.cron.Stop()
		s.running = false
		log.Info().Msg("Daily review scheduler stopped")
	}
	close(s.stop)
}

// sendDailyReviewReminder fetches problems needing review and sends a message to Discord
func (s *Scheduler) sendDailyReviewReminder(ctx context.Context) {
	if s.config.ReviewChannel == "" {
		log.Warn().Msg("Review channel not configured, skipping daily reminder.")
		return
	}

	users, err := s.bot.db.ListAllUsers(ctx) // Assuming you have a way to list all users who have added problems
	if err != nil {
		log.Error().Err(err).Msg("Failed to list users for review reminders")
		return
	}

	for _, userID := range users {
		problems, err := s.bot.db.ListProblemsForReview(ctx, userID, s.config.LookbackPeriod)
		if err != nil {
			log.Error().Err(err).Str("user_id", userID).Msg("Failed to list problems for review")
			continue
		}

		if len(problems) > 0 {
			user, err := s.bot.session.User(userID)
			if err != nil {
				log.Error().Err(err).Str("user_id", userID).Msg("Failed to get Discord user")
				continue
			}

			var sb strings.Builder
			sb.WriteString(fmt.Sprintf("Hey %s! Here are some problems you might want to review today:\n", user.Mention()))
			for _, p := range problems {
				sb.WriteString(fmt.Sprintf("- %s (Solved: %s)", p.ProblemName, p.SolvedAt.Format("2006-01-02")))
				if p.Link != "" {
					sb.WriteString(fmt.Sprintf(" - <%s>", p.Link))
				}
				sb.WriteString("\n")
			}
			sb.WriteString("\nRemember, consistent review helps reinforce your understanding!")

			_, err = s.bot.session.ChannelMessageSend(s.config.ReviewChannel, sb.String())
			if err != nil {
				log.Error().Err(err).Str("channel_id", s.config.ReviewChannel).Str("user_id", userID).Msg("Failed to send review reminder")
				// Implement retry logic if needed, based on s.config.RetryAttempts and s.config.RetryDelay
				for i := 0; i < s.config.RetryAttempts; i++ {
					time.Sleep(s.config.RetryDelay)
					_, retryErr := s.bot.session.ChannelMessageSend(s.config.ReviewChannel, sb.String())
					if retryErr == nil {
						log.Info().Str("channel_id", s.config.ReviewChannel).Str("user_id", userID).Int("attempt", i+1).Msg("Successfully sent review reminder after retry")
						break
					}
					log.Error().Err(retryErr).Str("channel_id", s.config.ReviewChannel).Str("user_id", userID).Int("attempt", i+1).Msg("Failed to send review reminder (retry)")
				}
			} else {
				log.Info().Str("channel_id", s.config.ReviewChannel).Str("user_id", userID).Int("problem_count", len(problems)).Msg("Sent daily review reminder")
				// Update last reviewed at for these problems to avoid repeated reminders too soon
				for _, p := range problems {
					if err := s.bot.db.IncrementReviewCount(ctx, p.ID); err != nil {
						log.Error().Err(err).Int("problem_id", p.ID).Msg("Failed to update review count")
					}
				}
			}
		}
	}
}

// Placeholder function to list all users who have added problems.
// You'll need to implement this based on your database schema.
func (db *database.DB) ListAllUsers(ctx context.Context) (string, error) {
	query := `SELECT DISTINCT user_id FROM problems`
	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query distinct user IDs: %w", err)
	}
	defer rows.Close()

	var usersstring
	for rows.Next() {
		var userID string
		if err := rows.Scan(&userID); err != nil {
			return nil, fmt.Errorf("failed to scan user ID: %w", err)
		}
		users = append(users, userID)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating over user IDs: %w", err)
	}

	return users, nil
}

//-----------------------------------------------------
// internal/metrics/metrics.go
//-----------------------------------------------------
package metrics

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/rs/zerolog/log"
	"github.com/yourusername/leetgrind-bot/config"
)

// Server represents the metrics server
type Server struct {
	httpServer *http.Server
	config     config.MetricsConfig
}

// New creates a new metrics server
func New(cfg config.MetricsConfig) *Server {
	mux := http.NewServeMux()
	mux.Handle("/metrics", promhttp.Handler())

	return &Server{
		httpServer: &http.Server{
			Addr:    cfg.Address,
			Handler: mux,
		},
		config: cfg,
	}
}

// Start starts the metrics server
func (s *Server) Start() error {
	log.Info().Str("address", s.config.Address).Msg("Starting metrics server")
	if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("metrics server failed: %w", err)
	}
	return nil
}

// Stop stops the metrics server gracefully
func (s *Server) Stop(ctx context.Context) error {
	log.Info().Msg("Stopping metrics server")
	shutdownCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()
	if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
		return fmt.Errorf("metrics server shutdown failed: %w", err)
	}
	return nil
}

//-----------------------------------------------------
// pkg/cache/cache.go
//-----------------------------------------------------
package cache

import (
	"sync"
	"time"
)

// Item represents a cached item
type Item struct {
	value      interface{}
	expiration int64
}

// Cache represents a simple in-memory cache
type Cache struct {
	items sync.Map
	defaultExpiration time.Duration
	cleanupInterval time.Duration
}

// New creates a new cache instance
func New(defaultExpiration, cleanupInterval time.Duration) *Cache {
	cache := &Cache{
		defaultExpiration: defaultExpiration,
		cleanupInterval: cleanupInterval,
	}
	go cache.cleanupExpired()
	return cache
}

// Set adds an item to the cache with a default expiration time
func (c *Cache) Set(key string, value interface{}) {
	c.SetWithExpiration(key, value, c.defaultExpiration)
}

// SetWithExpiration adds an item to the cache with a specified expiration time
func (c *Cache) SetWithExpiration(key string, value interface{}, expiration time.Duration) {
	var expiry int64
	if expiration > 0 {
		expiry = time.Now().Add(expiration).UnixNano()
	}
	c.items.Store(key, Item{value: value, expiration: expiry})
}

// Get retrieves an item from the cache
func (c *Cache) Get(key string) (interface{}, bool) {
	item, found := c.items.Load(key)
	if !found {
		return nil, false
	}
	cachedItem := item.(Item)
	if cachedItem.expiration > 0 && time.Now().UnixNano() > cachedItem.expiration {
		c.items.Delete(key)
		return nil, false
	}
	return cachedItem.value, true
}

// Delete removes an item from the cache
func (c *Cache) Delete(key string) {
	c.items.Delete(key)
}

// cleanupExpired periodically removes expired items from the cache
func (c *Cache) cleanupExpired() {
	ticker := time.NewTicker(c.cleanupInterval)
	defer ticker.Stop()
	for range ticker.C {
		c.items.Range(func(key, value interface{}) bool {
			item := value.(Item)
			if item.expiration > 0 && time.Now().UnixNano() > item.expiration {
				c.items.Delete(key)
			}
			return true
		})
	}
}

// DefaultCache is a convenient default cache instance
var DefaultCache = New(5*time.Minute, 1*time.Minute)

